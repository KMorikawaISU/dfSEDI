---
title: "dfSEDI"
output: github_document
---

# dfSEDI

dfSEDI implements semiparametric efficient data integration methods for dual-frame sampling (Morikawa & Kim, 202x).

Main user-facing estimators:

- `Eff`     : semiparametric efficient estimator (**default: DML1**, supports DML1 / DML2, K-fold)
- `Eff_S`   : sub-efficient estimator (Remark 6-type, K-fold)
- `Eff_P`   : parametric efficient estimator (working model)

For comparison (mainly for simulations), the package also includes:

- `df_estimate_P`     : probability-only estimator (HT-type)
- `df_estimate_NP`    : non-probability-only estimator (Chang & Kott-type; **requires `base_fun`**)
- `df_estimate_NP_P`  : NP union P estimator (Chang & Kott-type; **requires `base_fun`**)

All estimators return a point estimate for \\(\\theta = E(Y)\\), and sandwich-type SE/CI computed from influence-function / pseudo-outcome contributions.

---

## Installation

Install the development version from GitHub:

```r
# install.packages("devtools")
devtools::install_github("KMorikawaISU/dfSEDI")
```

Load the package:

```r
library(dfSEDI)
```

---

## Data format

All core functions assume a data frame `dat` that contains at least:

- `X`      : covariates used in the *parametric* NP inclusion model and also as inputs to nuisance models  
             - can be a **numeric matrix** stored as a single column, e.g. `X = I(matrix(...))`, or  
             - a **data.frame** (recommended if you have categorical variables)  
             - alternatively, a numeric vector `x` can be provided (1D covariate case)
- `y`      : outcome variable (continuous or binary)
- `d_np`   : indicator for inclusion in the non-probability sample (0/1)
- `d_p`    : indicator for inclusion in the probability sample (0/1)
- `pi_p`   : design inclusion probability for the probability sample
- `pi_np`  : (optional; simulations only) true NP inclusion probability

### Important: handling the \\((d_{np}, d_p) = (0,0)\\) pattern (`x_info`)

In the paper's notation, there are four response patterns \\((\\delta_{NP}, \\delta_P)\\in\\{0,1\\}^2\\).
In many *practical* data-integration tasks you only have units that appear in *either*
the probability sample or the non-probability sample, i.e. you only observe the union sample
\\(\\delta_{NP}\\cup\\delta_P = 1\\). In that common case, there are **no rows** with \\((d_{np}, d_p)=(0,0)\\).

The paper also notes that the theory covers the case where \\(X\\) is unavailable when \\((\\delta_{NP},\\delta_P)=(0,0)\\);
in that case, it suffices to set the augmentation functions \\(h_4^*(X)\\) and \\(\\eta_4^*(X)\\) to zero.

dfSEDI exposes this choice via the flag `x_info`:

- `x_info = FALSE` (**recommended for most real-data use cases**):  
  Use the simplified formulation with \\(h_4^*(X)=\\eta_4^*(X)=0\\).  
  This mode is intended for the common situation where you only have the union sample,
  or you do not have covariates \\(X\\) for \\((0,0)\\) units. It also avoids computations
  involving the \\((0,0)\\) pattern and can be substantially faster.

- `x_info = TRUE`:  
  Use the full formulation as written in the main text of the paper.  
  This is appropriate if you explicitly include \\((0,0)\\) units in `dat` **and** you have \\(X\\)
  for those units (e.g., simulation studies, or settings with a population register providing \\(X\\)).

> Practical tip: If your input data include only sampled units (union sample), you can create it as:
>
> ```r
> dat_union <- subset(dat, d_np == 1 | d_p == 1)
> ```

---

## Mixed continuous/discrete covariates (automatic)

dfSEDI estimates nuisance functions (e.g., \\(\\mu(X)=E[Y\\mid X]\\), \\(\\pi_P\\), \\(\\eta_4^*(X)\\), \\(h_4^*(X)\\)) using kernel methods.

- If `X` is continuous-only, dfSEDI uses Gaussian/RBF kernels (via `kernlab::gausspr`).
- If `X` contains **categorical/discrete** columns, dfSEDI automatically uses a **product kernel**:
  - RBF (Gaussian) kernel on continuous columns
  - Delta (Kronecker) kernel on categorical columns (only same-category pairs interact)

This is equivalent to fitting separate kernel models *within each category combination*, and it often yields **large speedups** because the kernel matrix becomes effectively block-diagonal.

#### How categorical columns are detected

- If `dat$X` is a **data.frame**, columns of type `factor`, `character`, or `logical` are treated as categorical.
- Numeric columns with “few” unique values may also be treated as categorical by a heuristic.

**Recommended practice:** supply `X` as a `data.frame` and explicitly mark categorical variables as `factor`.

> Note (parametric part for \\(\\phi\\)): If `X` is a `data.frame` with factor columns, dfSEDI internally uses dummy encoding (`model.matrix`) for the NP inclusion model so multi-level categorical variables enter as dummies automatically.

#### Small-cell warning (categorical cells)

With a delta kernel, very small categorical cells can make nuisance estimates unstable. dfSEDI can warn (or ask interactively) when cell sizes are too small. You can control this behavior via options, e.g.:

```r
options(dfSEDI.min_cell_size = 30)                 # threshold
options(dfSEDI.small_cell_action = "ask")          # "ask" / "warn" / "stop" / "none"
options(dfSEDI.allow_small_cells = FALSE)          # bypass flag
```

---

## Chang & Kott-type NP estimators: specifying `base_fun` (NEW)

`df_estimate_NP()` and `df_estimate_NP_P()` solve a Chang & Kott-type estimating equation for the NP propensity parameter \\(\\phi\\) using a user-supplied basis function:

- `base_fun` must be a function of the form `base_fun <- function(X) { ... }`
- `X` is the \\(n \\times p\\) design matrix extracted from `dat` (via `df_get_X(dat)`)
- `base_fun(X)` must return a **numeric matrix** with shape:

$$
B = \mathtt{base}\texttt{\_}\mathtt{fun}(X) \in \mathbb{R}^{n \times (p+2)}.
$$

### Strict validation

dfSEDI performs strict checks for safety:

- `nrow(base_fun(X))` must equal `nrow(X)`
- `ncol(base_fun(X))` must equal `ncol(X) + 2`
- all entries must be finite numeric values (no `NA`, `Inf`, `-Inf`)

If any check fails, the estimator stops with an error (rather than returning silent nonsense).

### Example `base_fun` choices

Quadratic augmentation (example):

```r
base_fun <- function(X) {
  cbind(1, X, X[, 1]^2)
}
```



> Tip: If you use a closure like this, make sure `base_fun` is defined for the same `dat` you pass into `df_estimate_NP()` / `df_estimate_NP_P()`.

---

## Example: one simulated dataset (no Monte Carlo)

The package ships an example script in `inst/examples`:

- `inst/examples/dualframe_simulation.R`

Example:

```r
library(dfSEDI)

# Load the bundled example script (defines generate_dualframe_population)
example_file <- system.file("examples", "dualframe_simulation.R", package = "dfSEDI")
source(example_file)

set.seed(18)
N <- 10000
dat <- generate_dualframe_population(N = N)

str(dat)
```

If you want `X` to contain an explicit categorical column (recommended in real data), you can do:

```r
dat$X <- data.frame(
  x1 = dat$X[, 1],
  x2 = factor(dat$X[, 2])
)
```

### Example A (typical): union sample only (`x_info = FALSE`)

If you want to mimic the most common real-data situation where you only observe the union sample:

```r
dat_union <- subset(dat, d_np == 1 | d_p == 1)

# Eff uses DML1 by default (faster).
fit_eff_union <- Eff(
  dat         = dat_union,
  K           = 3,
  x_info      = FALSE,
  progress    = TRUE
)

fit_eff_union$theta
fit_eff_union$se
fit_eff_union$ci
fit_eff_union$info
```

### Example B (simulation / full info): include \\((0,0)\\) rows (`x_info = TRUE`)

For simulation studies where you keep the full population-like data structure:

```r
# Eff uses DML1 by default (faster).
fit_eff_full <- Eff(
  dat         = dat,
  K           = 3,
  x_info      = TRUE,
  progress    = TRUE
)

fit_eff_full$theta
fit_eff_full$se
fit_eff_full$ci
fit_eff_full$info
```

---

## Eff: DML (DML1 default)

`Eff()` supports two DML variants:

- `type = 1` (or `"DML1"`) : **DML1 (default; usually faster)**
- `type = 2` (or `"DML2"`) : DML2 (optional; can be slower)

Why DML1 is typically faster in practice:

- DML1 estimates fold-specific quantities and aggregates them.
- DML2 can require evaluating an objective for \\(\\phi\\) many times; depending on the nuisance models, this may refit expensive regressions repeatedly.

### Eff: DML1 (default)

DML1 conceptually computes fold-specific estimates and aggregates them:

- split data into folds \\(S_1, \\ldots, S_K\\)
- for each fold \\(k\\):
  - estimate nuisances (including \\(\\pi_p\\)) on training data (all folds except \\(k\\))
  - compute fold-specific estimates on test fold \\(k\\)
- aggregate fold-specific estimates across \\(k\\)

DML1 example (default):

```r
fit_eff_dml1 <- Eff(
  dat         = dat,
  K           = 3,
  # type      = 1,      # optional (DML1 is the default)
  phi_start   = NULL,
  max_restart = 10,
  x_info      = TRUE,   # or FALSE if you only have the union sample
  progress    = TRUE
)

fit_eff_dml1$phi
fit_eff_dml1$theta
fit_eff_dml1$se
fit_eff_dml1$ci
fit_eff_dml1$info
```

### Eff: DML2 (optional)

DML2 example:

```r
fit_eff_dml2 <- Eff(
  dat         = dat,
  K           = 2,
  type        = 2,      # DML2
  phi_start   = NULL,
  max_restart = 10,
  x_info      = TRUE,   # or FALSE if you only have the union sample
  progress    = TRUE
)

fit_eff_dml2$phi
fit_eff_dml2$theta
fit_eff_dml2$se
fit_eff_dml2$ci
fit_eff_dml2$info
```

Eff returns joint sandwich-based standard errors for both \\(\\theta\\) and \\(\\phi\\)
(`phi_se`, `phi_ci`).

> Tip: If you do not have \\((0,0)\\) units / do not have \\(X\\) for them, using `x_info = FALSE` can be much faster.
> This is common when your dataset is the union sample only.

---

## Comparison estimators (P / NP / NP ∪ P)  ✅ Updated for `base_fun`

For simulations, it is sometimes useful to compare `Eff` against simpler estimators:

- `df_estimate_P()`     : probability-only estimator (HT-type)
- `df_estimate_NP()`    : non-probability-only estimator (Chang & Kott-type; requires `base_fun`)
- `df_estimate_NP_P()`  : NP union P estimator (Chang & Kott-type; requires `base_fun`)

These are mainly intended for **simulation settings** where `dat` contains a “population-like”
structure (including \\((0,0)\\) units) and `pi_p` is defined for the full frame.

Example:

```r
# Probability-only (HT-type)
fit_P <- df_estimate_P(dat)

# Define the basis for the NP inclusion model
base_fun <- function(X) {
  cbind(1, X, X[, 1]^2)
}

# Non-probability-only (Chang & Kott-type)
fit_NP <- df_estimate_NP(dat, base_fun = base_fun)

# NP union P (Chang & Kott-type)
# NOTE: pi_p must be fully observed (no NA/Inf), or you must impute first.
fit_NP_P <- df_estimate_NP_P(dat, base_fun = base_fun)

c(
  Eff   = fit_eff_full$theta,
  P     = fit_P$theta,
  NP    = fit_NP$theta,
  NP_P  = fit_NP_P$theta
)
```

Each returns `theta`, `se`, `ci`:

```r
fit_P$theta;    fit_P$se;    fit_P$ci
fit_NP$theta;   fit_NP$se;   fit_NP$ci
fit_NP_P$theta; fit_NP_P$se; fit_NP_P$ci
```

> Note: `df_estimate_NP()` / `df_estimate_NP_P()` solve estimating equations and may return `NA`
> if the solver fails to converge. This is expected in some small samples or unstable designs.

---

## Eff_S (sub-efficient)

```r
fit_effS <- Eff_S(
  dat      = dat,
  K        = 2,
  progress = TRUE
)

fit_effS$theta
fit_effS$se
fit_effS$ci
fit_effS$info
```

`Eff_S` is based on a sub-efficient influence function that only involves the outcome
regression \\(\\mu(X)=E(Y \\mid X)\\).

---

## Eff_P (parametric working model)

```r
fit_effP <- Eff_P(
  dat       = dat,
  phi_start = NULL,
  eta4_star = 0,
  max_iter  = 20,
  progress  = TRUE
)

fit_effP$phi
fit_effP$theta
fit_effP$se
fit_effP$ci
fit_effP$info
```

`Eff_P` assumes parametric working models for both the sampling mechanism and the
outcome regression. It returns point estimates and standard errors for \\(\\theta\\);
standard errors for \\(\\phi\\) are not currently implemented in `Eff_P`.

---

## Binary outcomes (Y is 0/1): logistic models for Eff_S and Eff_P

If the outcome `y` is binary (0/1), dfSEDI can use logistic models for the outcome regression \\(\\mu(X)=P(Y=1\\mid X)\\):

- **Eff_S**: \\(\\mu(X)\\) is estimated by **kernel logistic regression** (RBF / mixed kernel + ridge regularization).
- **Eff_P**: \\(\\mu(X)\\) is estimated by **parametric logistic regression** (`glm(..., family=binomial())`).

### How dfSEDI decides whether `y` is binary

`y` is treated as binary if it is one of:

- numeric/integer with exactly two unique finite values (e.g. 0/1),
- `logical`,
- a 2-level `factor` (or `character`, which will be treated like a 2-level factor).

By default, both `Eff_S()` and `Eff_P()` have `logit = NULL`, which means:

- If `y` is binary, dfSEDI **automatically uses logistic models** for \\(\\mu(X)\\).
- If `y` is not binary, dfSEDI uses the original models:
  - Eff_S: kernel ridge regression for \\(\\mu(X)\\)
  - Eff_P: linear regression for \\(\\mu(X)\\)

You can override this behavior explicitly:

```r
# Force logistic (errors if y is not binary)
fit_effS_bin <- Eff_S(dat, K = 2, logit = TRUE)
fit_effP_bin <- Eff_P(dat, logit = TRUE)

# Force non-logistic (even if y is binary)
fit_effS_lin <- Eff_S(dat, K = 2, logit = FALSE)
fit_effP_lin <- Eff_P(dat, logit = FALSE)
```

### Note on coding of success (=1)

- If `y` is a 2-level factor, dfSEDI treats the **second level** as the success category (=1).
- If `y` is numeric with two unique values, dfSEDI treats the **larger value** as success (=1).

To avoid ambiguity, you can always recode explicitly to `0/1` (or reorder factor levels) before calling dfSEDI.

---

## Returned object structure

`Eff`, `Eff_S`, and `Eff_P` return a list with (at least):

- `theta` : point estimate of \\(\\theta = E(Y)\\)
- `var`   : sandwich variance estimate for `theta`
- `se`    : sandwich standard error for `theta`
- `ci`    : 95% confidence interval for `theta`

For the propensity parameter \\(\\phi\\):

- `Eff` (DML1 / DML2) returns
  - `phi`     : estimate of the NP propensity parameter
  - `phi_var` : joint sandwich variance matrix for `phi`
  - `phi_se`  : standard errors for each component of `phi`
  - `phi_ci`  : 95% confidence intervals for each component of `phi`

- `Eff_P` returns `phi` but currently leaves `phi_var`, `phi_se`, and `phi_ci` as `NULL`.

The `info` element stores meta information (K, type, convergence code, etc.) that can
be useful for diagnostics.
